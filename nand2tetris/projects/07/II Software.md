# II Software

충분히 발전된 기술은 마법과 구별할 수 없습니다. 

—Arthur C. Clarke (1962)

우리가 더하자면 "그리고 충분히 발전된 마법은 보이지 않는 고된 작업과 구분할 수 없습니다."

책의 1부에서 우리는 Hack 기계 언어로 작성된 프로그램을 실행할 수 있는 Hack이라는 컴퓨터 시스템의 하드웨어 플랫폼을 구축했습니다. 2부에서는 이 베어본 머신을 마법과 구별할 수 없는 고급 기술로 변환합니다. 블랙박스는 체스 플레이어, 검색 엔진, 비행 시뮬레이터, 미디어 스트리머 또는 당신의 공상을 간지럽히는 모든 것으로 변신할 수 있습니다. 그렇게 하기 위해 우리는 고급 프로그래밍 언어로 작성된 프로그램을 실행할 수 있는 능력을 컴퓨터에 부여하는 정교한 배후의 소프트웨어 계층 구조를 펼칠 것입니다. 특히 9장에서 공식적으로 설명한 단순하고 Java와 유사한 객체 기반 프로그래밍 언어인 Jack에 초점을 맞출 것입니다. 수년 동안 Nand에서 Tetris 독자와 학생들은 Jack을 사용하여 Tetris, Pong, Snake, Space Invaders, 기타 수많은 게임 및 대화형 앱. 범용 컴퓨터인 Hack은 이러한 모든 프로그램과 마음에 떠오르는 다른 프로그램을 실행할 수 있습니다.

분명히, 한편으로는 고급 프로그래밍 언어의 표현 구문과 다른 한편으로는 저급 기계 언어의 투박한 명령 사이의 격차는 엄청납니다. 확신이 서지 않으면 @17 및 와 같은 지침을 사용하여 Tetris 게임을 개발해 보십시오. 이 격차를 해소하는 것이 이 책의 2부에서 다루고 있는 내용입니다. 우리는 응용 컴퓨터 과학에서 가장 강력하고 야심찬 프로그램인 컴파일러, 가상 머신 및 기본 운영 체제를 점진적으로 개발하여 이 가교를 구축할 것입니다.

우리의 Jack 컴파일러는 Jack 프로그램(예: Tetris)을 사용하여 실행될 때 Hack 플랫폼이 Tetris 게임 경험을 제공하도록 하는 기계어 명령 스트림을 생성하도록 설계됩니다. 물론 Tetris는 하나의 예일 뿐입니다. 여러분이 빌드하는 컴파일러는 주어진 Jack 프로그램을 Hack 컴퓨터에서 실행할 수 있는 기계 코드로 변환할 수 있습니다. 주요 작업이 구문 분석 및 코드 생성으로 구성된 컴파일러는 10장과 11장에서 구축됩니다.

Java 및 C#과 같은 프로그래밍 언어와 마찬가지로 Jack 컴파일러는 2계층으로 구성됩니다. 컴파일러는 추상 가상 머신에서 실행되도록 설계된 임시 VM 코드를 생성합니다. 그런 다음 VM 코드는 별도의 번역기에 의해 Hack 기계 언어로 추가로 컴파일됩니다. 응용 컴퓨터 과학에서 가장 중요한 아이디어 중 하나인 가상화는 프로그램 편집, 클라우드 컴퓨팅, 분산 스토리지, 분산 처리 및 운영 체제를 비롯한 다양한 설정에서 활용됩니다. 7장과 8장은 가상 머신의 동기 부여, 설계 및 구축에 할애할 것입니다.

다른 많은 고급 언어와 마찬가지로 기본 Jack 언어는 놀라울 정도로 간단합니다. 현대 언어를 강력한 프로그래밍 시스템으로 바꾸는 것은 수학 함수, 문자열 처리, 메모리 관리, 그래픽 그리기, 사용자 상호 작용 처리 등을 제공하는 표준 라이브러리입니다. 종합하면 이러한 표준 라이브러리는 Jack 프레임워크에서 Jack의 표준 클래스 라이브러리로 패키징되는 기본 운영 체제(OS)를 형성합니다. 상위 수준의 Jack 언어와 하위 수준의 Hack 플랫폼 사이의 많은 격차를 해소하도록 설계된 이 기본 OS는 Jack 자체에서 개발될 것입니다. 프로그래밍 언어를 가능하게 하는 소프트웨어를 동일한 언어로 개발할 수 있는 방법이 궁금할 수 있습니다. 우리는 Unix OS가 C 언어를 사용하여 개발된 방식과 유사한 부트스트래핑으로 알려진 개발 전략을 따라 이 문제를 처리할 것입니다.

OS의 구성은 일반적으로 하드웨어 리소스 및 주변 장치를 관리하는 데 사용되는 우아한 알고리즘과 고전적인 데이터 구조를 제시할 수 있는 기회를 제공할 것입니다. 그런 다음 Jack에서 이러한 알고리즘을 구현하여 언어의 기능을 한 번에 한 단계씩 확장합니다. 파트 II의 장을 진행하면서 여러 다른 관점에서 OS를 다루게 됩니다. 9장에서는 응용 프로그램 프로그래머 역할을 하면서 높은 수준의 클라이언트 관점에서 Jack 앱을 개발하고 OS 서비스를 추상적으로 사용합니다. 10장과 11장에서는 Jack 컴파일러를 빌드할 때 컴파일러에 필요한 다양한 메모리 관리 서비스와 같이 OS 서비스를 하위 수준 클라이언트로 사용합니다. 12장에서는 마침내 OS 개발자의 모자를 쓰고 이러한 모든 시스템 서비스를 직접 구현하게 됩니다.

## II.1 A Taste of Jack Programming

이 흥미로운 프로젝트를 모두 살펴보기 전에 Jack 언어에 대해 간략하고 비공식적인 소개를 하겠습니다. 이는 Hello World로 시작하는 두 가지 예를 사용하여 수행됩니다. 우리는 이 예제를 사용하여 가장 사소한 고급 프로그램도 눈에 보이는 것보다 훨씬 더 많은 것을 가지고 있음을 보여줄 것입니다. 그런 다음 Jack 언어의 개체 기반 기능을 설명하는 간단한 프로그램을 제시합니다. 프로그래머 중심의 고급 Jack 언어를 맛보면 가상 머신, 컴파일러 및 운영 체제를 구축하여 언어를 구현하는 여정을 시작할 수 있습니다.

Hello World, again: 우리는 학습자가 프로그래밍 입문 과정에서 가장 먼저 접하게 되는 상징적인 Hello World 프로그램으로 이 책을 시작했습니다. 다음은 Jack 프로그래밍 언어로 작성된 이 간단한 프로그램입니다.

```java
// First example in Programming 101 class Main {
function void main () {
	do Output.printString ("Hello World"); return;
	}
}
```

실제로 고급 프로그래밍 언어의 아름다움과 일반적으로 잘 설계된 추상화의 아름다움은 행복한 무지 상태에서 사용할 수 있다는 것입니다. 실제로 응용 프로그램 프로그래머는 언어가 실제로 구현되는 방식에 주의를 기울이지 않고 언어를 블랙 박스 추상화로 보도록 권장됩니다. 좋은 튜토리얼과 몇 가지 코드 예제만 있으면 됩니다.

하지만 분명히 언젠가는 누군가가 이 언어 추상화를 구현해야 합니다. 응용 프로그램 프로그래머가 만족스럽게 sqrt(1764)라고 말할 때 누군가가 효율적으로 제곱근을 계산하는 기능을 개발해야 합니다. 프로그래머는 new를 사용하여 무심코 객체를 생성하고 프로그래머가 생각하지 않고 얻을 것으로 기대하는 다른 모든 추상 서비스를 투명하게 수행합니다. 그렇다면 고급 프로그래밍을 마법과 구별할 수 없는 고급 기술로 바꾸는 선한 영혼은 누구입니까? 이들은 컴파일러, 가상 머신 및 운영 체제를 개발하는 소프트웨어 마법사입니다. 이것이 바로 다음 장에서 수행할 작업입니다.

이 애매한 비하인드를 왜 굳이 신경써야 하는지 의구심이 들 수도 있습니다. 작동 방식에 대해 걱정하지 않고 고급 언어를 사용할 수 있다고 방금 말하지 않았습니까? 적어도 두 가지 이유가 있습니다. 첫째, 낮은 수준의 시스템 내부를 더 많이 탐구할수록 더 정교한 고급 프로그래머가 됩니다. 특히 하드웨어와 OS를 영리하고 효율적으로 활용하는 고급 코드를 작성하는 방법과 메모리 누수와 같은 당혹스러운 버그를 피하는 방법을 배웁니다.

둘째, 손을 더럽히고 시스템 내부를 직접 개발함으로써 응용 컴퓨터 과학에서 가장 아름답고 강력한 알고리즘과 데이터 구조를 발견하게 될 것입니다. 중요한 것은 II부에서 전개될 아이디어와 기술이 컴파일러와 운영 체제에 국한되지 않는다는 것입니다. 오히려 그들은 경력 전반에 걸쳐 함께 할 수많은 소프트웨어 시스템 및 응용 프로그램의 구성 요소입니다.

PointDemo 프로그램: 평면에서 점을 표현하고 조작한다고 가정합니다. 그림 II.1은 벡터 덧셈 p3=p1+p2=(1,2)+(3,4)=(4,6)의 결과인 두 개의 점 p1과 p2와 세 번째 점 p3을 보여줍니다. 그림은 또한 피타고라스 정리를 사용하여 계산할 수 있는 p1과 p3 사이의 유클리드 거리를 나타냅니다. Main 클래스의 코드는 객체 기반 Jack 언어를 사용하여 이러한 대수적 조작을 수행하는 방법을 보여줍니다.

![Untitled](II%20Software/Untitled.png)

Jack이 var, let 및 do와 같은 키워드를 사용하는 이유가 궁금할 수 있습니다. 지금은 구문 세부 사항에 연연하지 않는 것이 좋습니다. 대신 큰 그림에 초점을 맞추고 Point 추상 데이터 유형을 구현하기 위해 Jack 언어를 어떻게 사용할 수 있는지 검토해 보겠습니다(그림 II.2).

![Untitled](II%20Software/Untitled%201.png)

그림 II.2에 표시된 코드는 Jack 클래스(Main 및 Point가 두 가지 예임)가 각각 생성자, 메소드 또는 함수인 하나 이상의 서브루틴 모음임을 보여줍니다. 생성자는 새 객체를 생성하는 서브루틴이고, 메소드는 현재 객체에 대해 작동하는 서브루틴이며, 함수는 특정 객체에 대해 작동하지 않는 서브루틴입니다. (객체 지향 설계 순수주의자는 같은 클래스에서 메서드와 함수를 혼합하는 것에 대해 눈살을 찌푸릴 수 있습니다. 여기서는 설명을 위해 그렇게 하고 있습니다.)

이 섹션의 나머지 부분은 Main 및 Point 클래스에 대한 비공식적인 개요입니다. 우리의 목표는 완전한 언어 설명을 9장으로 미루고 Jack 프로그래밍의 맛을 보는 것입니다. 따라서 본질에만 집중하는 사치를 허용하고 시작하겠습니다. Main.main 함수는 Point 클래스의 인스턴스를 참조하도록 설계된 세 개의 개체 변수(참조 또는 포인터라고도 함)를 선언하는 것으로 시작합니다. 그런 다음 계속해서 두 개의 Point 개체를 구성하고 p1 및 p2 변수를 할당합니다. 그런 다음 plus 메서드를 호출하고 해당 메서드에서 반환된 Point 개체에 p3를 할당합니다. Main.main 함수의 나머지 부분은 일부 결과를 인쇄합니다.

Point 클래스는 모든 Point 개체가 두 개의 필드 변수(속성 또는 인스턴스 변수라고도 함)로 특징지어진다고 선언하는 것으로 시작합니다. 그런 다음 정적 변수, 즉 특정 개체와 연결되지 않은 클래스 수준 변수를 선언합니다. 클래스 생성자는 새로 생성된 개체의 필드 값을 설정하고 지금까지 이 클래스에서 파생된 인스턴스 수를 증가시킵니다. Jack 생성자는 새로 생성된 객체의 메모리 주소를 명시적으로 반환해야 하며 언어 규칙에 따라 this로 표시됩니다.

거리 방법으로 계산한 제곱근의 결과가 int 변수에 저장되는 이유가 궁금할 수 있습니다. 분명히 float와 같은 실수 값 데이터 유형이 더 적합할 것입니다. 이러한 특수성에 대한 이유는 간단합니다. Jack 언어에는 int, boolean 및 char의 세 가지 기본 데이터 유형만 있습니다. 다른 데이터 유형은 9장과 12장에서 수행할 것처럼 클래스를 사용하여 마음대로 구현할 수 있습니다.

운영 체제: Main 및 Point 클래스는 Output.printInt, Output.printString 및 Math.sqrt의 세 가지 OS 함수를 사용합니다. 다른 최신 고급 언어와 마찬가지로 Jack 언어는 일반적으로 사용되는 OS 서비스를 제공하는 일련의 표준 클래스로 보강됩니다(완전한 OS API는 부록 6에 제공됨). OS 서비스에 대해서는 9장에서 Jack 프로그래밍의 맥락에서 사용할 뿐만 아니라 12장에서 OS를 구축할 것입니다.

효과를 위해 OS 서비스를 Jack 프로그램에서 직접 호출하는 것 외에도 OS는 덜 분명한 다른 방식으로 작동하게 됩니다. 예를 들어 객체 지향 언어에서 객체를 구성하는 데 사용되는 새로운 작업을 고려하십시오. 컴파일러는 호스트 RAM에서 새로 생성된 개체를 넣을 위치를 어떻게 알 수 있습니까? 글쎄요. 이를 파악하기 위해 OS 루틴이 호출됩니다. 12장에서 OS를 구축할 때 무엇보다도 일반적인 런타임 메모리 관리 시스템을 구현하게 됩니다. 그런 다음 이 시스템이 RAM 공간을 영리하고 효율적으로 할당하고 회수하기 위해 한쪽 끝에서 하드웨어와 다른 쪽 끝에서 컴파일러와 상호 작용하는 방법을 직접 배우게 됩니다. 이는 OS가 상위 수준 애플리케이션과 호스트 하드웨어 플랫폼 사이의 간격을 연결하는 방법을 보여주는 한 가지 예일 뿐입니다.

## II.2 Program Compilation

고급 프로그램은 기본 하드웨어에 아무런 의미가 없는 상징적인 추상화입니다. 프로그램을 실행하기 전에 고급 코드를 기계어로 번역해야 합니다. 이 번역 과정을 컴파일(compilation)이라고 하고, 이를 수행하는 프로그램을 컴파일러(compiler)라고 합니다. 높은 수준의 프로그램을 낮은 수준의 기계 명령어로 변환하는 컴파일러를 작성하는 것은 가치 있는 도전입니다. 예를 들어 Java 및 C#과 같은 일부 언어는 우아한 2계층 컴파일 모델을 사용하여 이 문제를 처리합니다. 먼저 소스 프로그램은 임시 추상 VM 코드(Java 및 Python에서는 바이트코드, C#/.NET에서는 중간 언어라고 함)로 변환됩니다. 다음으로, 완전히 분리되고 독립적인 프로세스를 사용하여 VM 코드를 모든 대상 하드웨어 플랫폼의 기계어로 번역할 수 있습니다.

이러한 모듈성은 Java가 지배적인 프로그래밍 언어가 된 이유 중 하나 이상입니다. 역사적인 관점에서 볼 때 Java는 컴퓨터가 몇 가지 예측 가능한 프로세서/OS 플랫폼에서 수많은 프로세서/OS 플랫폼으로 진화하기 시작했을 때 적절한 시기에 2계층 컴파일 모델이 적합한 강력한 객체 지향 언어로 볼 수 있습니다. PC, 휴대폰, 모바일 장치 및 사물 인터넷 장치는 모두 글로벌 네트워크로 연결됩니다. 이러한 호스트 플랫폼 중 하나에서 실행할 수 있는 고급 프로그램을 작성하는 것은 어려운 과제입니다. 이 분산된 다중 공급업체 에코시스템(컴파일 관점에서)을 간소화하는 한 가지 방법은 합의된 가상 머신 아키텍처에 기반을 두는 것입니다. 공통 중간 런타임 환경으로 작동하는 VM 접근 방식을 통해 개발자는 각각 고유한 VM 구현을 갖춘 다양한 하드웨어 플랫폼에서 거의 그대로 실행되는 고급 프로그램을 작성할 수 있습니다. 2부가 전개되면서 이 모듈성의 가능 능력에 대해 더 많은 이야기를 하게 될 것입니다.

앞으로의 길: 이 책의 나머지 부분에서는 위에서 언급한 모든 흥미로운 소프트웨어 기술을 개발하는 데 전념할 것입니다. 우리의 궁극적인 목표는 높은 수준의 프로그램(모든 프로그램)을 실행 가능한 코드로 전환하기 위한 인프라를 만드는 것입니다. 로드맵은 그림 II.3에 나와 있습니다.

![Untitled](II%20Software/Untitled%202.png)

파트 II의 로드맵(어셈블러는 파트 I에 속하며 완전성을 위해 여기에 표시됨). 로드맵은 상위 수준의 개체 기반 다중 클래스 프로그램에서 VM 코드, 어셈블리 코드, 실행 가능한 이진 코드에 이르는 변환 계층 구조를 설명합니다. 번호가 매겨진 원은 컴파일러, VM 변환기, 어셈블러 및 운영 체제를 구현하는 프로젝트를 나타냅니다. 프로젝트 9는 언어에 익숙해지기 위해 Jack 애플리케이션 작성에 중점을 둡니다.

Nand to Tetris 정신에 따라 우리는 아래에서 위로 파트 II 로드맵을 추구할 것입니다. 시작하려면 어셈블리 언어가 장착된 하드웨어 플랫폼이 있다고 가정합니다. 7~8장에서는 가상 머신 아키텍처와 VM 언어를 제시하고 VM 프로그램을 Hack 어셈블리 프로그램으로 변환하는 VM 변환기를 개발하여 이 추상화를 구현할 것입니다. 9장에서는 Jack 고급 언어를 제시하고 간단한 컴퓨터 게임을 개발하는 데 사용할 것입니다. 이렇게 하면 빌드를 시작하기 전에 Jack 언어와 운영 체제에 익숙해질 수 있습니다. 10~11장에서는 Jack 컴파일러를 개발하고 12장에서는 운영 체제를 구축합니다. 자, 소매를 걷어붙이고 일하러 갑시다.