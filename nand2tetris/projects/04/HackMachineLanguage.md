# Hack Machine Language Specification

핵 컴퓨터는 폰 노이만 플랫폼이다. 그리고 CPU, 명령용과 데이터용으로 분리된 메모리 모듈 두 개, 그리고 메모리 매핑 I/O장치(스크린과 키보드) 두 개로 구성된 16비트 장치이다.

-----
### 1. 메모리 주소 공간
- 명령어 메모리(instruction memory)
: 핵컴퓨터는 ROM(Read Only Memory)에 미리 새겨진 명령어 메모리에 존재하는 프로그램만 수행한다.
- 데이터 메모리(data memory)
: 데이터 값을 읽고 쓰는 메모리다.

### 2. 레지스터
: 핵 시스템에는 D와 A라 불리는 16비트 레지스터가 두 개 있다. 이 레지스터들은 A=D-1 같은 산술 명령이나, D=!A(여기서 '!'은 16비트 Not 연산을 뜻한다) 같은 논리 명령으로 직접 조작된다. 여기서 D는 명령을 수행한 데이터 값을 저장하는 용도로만 쓰이는 반면, A는 임의의 상수 또는 데이터메모리의 주소, 명령어메모리의 주소로 해석될 수 있다. 여기서 A는 M이라는 이름의 주소로만 메모리 접근이 가능하도록 강제한다. 다시 말해, 주소가 A인 메모리 안에 든 값을 참조하는 변수가 M인 것이다.
1) D=M+1 같은 식이다.
2) D=Memory[516]-1 같은 연산을 하려면, A레지스터에 516을 넣고, 그 다음에 D=M-1 명령어를 실행해야 한다.
3) A레지스터는 명령어 메모리에 직접 접근하는 용도로 쓰인다. goto 35 연산을 하려면, A의 값으로 35를 넣은 후에 바로 주소 없이 goto 명령을 내리면 된다. 컴퓨터는 이 두 명령어를 만나면 다음 클록 사이클 때 instructionMemory[35]에 위치한 명령어를 불러온다.

4) A레지스터 쓰기: @value 명령어는 A레지스터에 value 값을 저장하라는 명령어다. 만약 변수 sum이 메모리 위치 17를 참조한다면, @17 과 @sum 둘다 A <-- 17을 수행한다. 

16bit를 1word로 받아들이며 word의 첫 비트가 0이면 주소를, 1이면 명령을 뜻함을 알린다. 나머지 15비트에는 메모리주소나 명령세부내용이 뒤따른다.

### 3. A-명령어
    @value 
    : A-레지스터에 value 입력음수가 아닌 10진수,
      또는 그 수를 참조하는 기호
    16-Binary: 0vvv vvvv vvvv vvvv
    (예시) @5 => A = 0000 0000 0000 0101

### 4. C-명령어
    dest=comp;jump (목적=연산;goto)
    : dest나 jump 필드는 공란일 수 있다.
      dest가 공란이면 '='가 생략된다.
      jump가 공란이면, ';'가 생략된다.
    16-Binary: 111a cccc ccdd djjj
    a: 연산시 a=0이면 A, a=1이면 M 값을 가리킴.
    c: 계산 필드
    d: 목적지(결과값) 필드
    j: 조건에 따른 점프 필드

(작성중)